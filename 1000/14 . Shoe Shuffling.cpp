/*
     ॐ त्र्यम्बकं यजामहे सुगन्धिं पुष्टिवर्धनम् |
     उर्वारुकमिव बन्धनान्मृत्योर्मुक्षीय माऽमृतात् ||
*/

#include <bits/stdc++.h>

using namespace std;

#define int            long long int
#define F              first
#define S              second
#define pb             push_back
#define si             set <int>
#define vi             vector <int>
#define pii            pair <int, int>
#define vpi            vector <pii>
#define vpp            vector <pair<int, pii>>
#define mii            map <int, int>
#define mpi            map <pii, int>
#define spi            set <pii>
#define endl           "\n"
#define sz(x)          ((int) x.size())
#define all(p)         p.begin(), p.end()
#define double         long double
#define que_max        priority_queue <int>
#define que_min        priority_queue <int, vi, greater<int>>
#define bug(...)       __f (#__VA_ARGS__, __VA_ARGS__)
#define print(a)       for(auto x : a) cout << x << " "; cout << endl
#define print1(a)      for(auto x : a) cout << x.F << " " << x.S << endl
#define print2(a,x,y)  for(int i = x; i < y; i++) cout<< a[i]<< " "; cout << endl

inline int power(int a, int b)
{
    int x = 1;
    while (b)
    {
        if (b & 1) x *= a;
        a *= a;
        b >>= 1;
    }
    return x;
}

template <typename Arg1>
void __f (const char* name, Arg1&& arg1) { cout << name << " : " << arg1 << endl; }
template <typename Arg1, typename... Args>
void __f (const char* names, Arg1&& arg1, Args&&... args)
{
    const char* comma = strchr (names + 1, ',');
    cout.write (names, comma - names) << " : " << arg1 << " | "; __f (comma + 1, args...);
}


/*-------------------------------------------------------------------------------------------------*/


/*

Editorial

We can observe that the number of pairs of shoes greater than their size is limited for any student. So if student j
wears shoes that are greater than their size, then some student i who has a size greater than student j will compromise 
their size. So say a valid shuffling exists where a student gets shoes of size greater than their own, i.e., student j
got shoes of student i where si>sj. Then, for all pairs of shoes of size sj, one pair will go to a student whose size is 
smaller than sj. This chain will continue until a student with shoe size s1 gets a pair of shoes greater than theirs, and 
then there will exist a pair of shoes of size s1 that no student can wear. Thus, if a valid shuffling, every student 
must get shoes of the same size as their own.

Hence, a valid shuffling exists if more than one student has the same size shoes for all shoe sizes. A valid shuffling can 
be generated by rearranging students' shoes with the same shoe size such that no one gets their shoes. This can be done in 
multiple ways, for example, cyclic rotation.




Idea :
The idea is trivial since no student should get his own shoe after the shuffle and also the shoe size should be greater.
Imagine the shoe size array with indices starting from one. Now keep the a[i]s{shoe size} constant in their places move the indices{students}. 
Notice since the array is sorted in non decreasing order so for a specific i selected it should go right so that he gets a shoe of greater size and in response a jth student will be there at last
who will have to come left which means he will get a smaller shoe size .
This shuffle is only succesful when there are atleast 2 guys with same shoe size always , so the jth guy can always come left getting a diff shoe of same size and not a smaller size.

Implementation 
we check that the count of longest segment with equal elements is ateast 2  or else cout<<-1 
and we just give cyclic rotation(by swapping) to the segments (equal shoe size).


*/

const int N = 200005;


void solve() {
    int n;cin>>n;
    int a[n];
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    if(n==1){
        cout<<-1<<endl;
        return;
    }
    //print(a);
    int count=1;
    int b[n];
  //filling the array b with students how they are initially (as per the increasing shoe size )
    for(int i=0;i<n;i++){
        b[i]=i+1;
    }
    for(int i=1;i<n;i++){
        if(a[i]==a[i-1]){
            count++;
            swap(b[i],b[i-1]); // technically only swapping students who have same shoe size so that the student who conmes left never gets a shoe of lower size.
        }
        else{
            if(count==1){
                cout<<-1<<endl;
                return;
            }
            count=1;
        }
    }
  //why we have to check the count here again is quite popular implementation detail when it comes to counting and checking lengths of subsequences.
    if(count==1){
        cout<<-1<<endl;
        return;
    }

  //printing the final array which stores the answer.
    for(int i=0;i<n;i++)cout<<b[i]<<" ";
    cout<<endl;

}

/*-------------------------------------------------------------------------------------------------*/



int32_t main()
{
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);


#ifndef ONLINE_JUDGE
    freopen("input.txt",  "r",  stdin);
    freopen("output.txt", "w", stdout);
#endif

    clock_t z = clock();

/*-------------------------------------------------------------------------------------------------*/


    int t = 1;
    cin >> t;
    while (t--) solve();

    cerr << "Run Time : " << ((double)(clock() - z) / CLOCKS_PER_SEC);

    return 0;


/*-------------------------------------------------------------------------------------------------*/
}
